<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      //// level.1 신규아이디 추천
      //let arg = "z-+.^."
      // function solution(new_id) {
      //     let answer = '';

      //     new_id.toLowerCase()
      //     .split("").forEach((item)=>{
      //         if(/^[a-z0-9\-_.]*$/.test(item)) answer = answer + item;
      //     })

      //     answer = answer.split("");
      //     let delSpotIndex = [];
      //     answer.map((item, index)=>{
      //         if(item === ".") return index;
      //     }).forEach((v, idx, arr)=>{
      //        if(arr[idx] + 1 === arr[idx+1]) delSpotIndex.push(idx)
      //     })
      //     for (let i = delSpotIndex.length -1; i >= 0; i--){
      //         answer.splice(delSpotIndex[i],1);
      //     }

      //     answer = answer.join("");
      //     if(answer.indexOf(".") === 0) answer = answer.substring(1, answer.length);
      //     if(answer.lastIndexOf(".") === answer.length-1) answer = answer.substring(0, answer.length-1);

      //     if(answer === "") answer = "a"

      //     if(answer.length >= 16){
      //         answer = answer.substring(0, 15);
      //         if(answer.lastIndexOf(".") === answer.length-1) answer = answer.substring(0, 14)
      //     }

      //     if(answer.length <= 2){
      //         for(let i = answer.length-1; i < 2; i++){
      //             answer = answer + answer[i];
      //         }
      //     }

      //     return answer;
      // }

      // //k번째 수
      // let arg = [1, 5, 2, 6, 3, 7, 4];
      // let arg2 = [[2, 5, 3], [4, 4, 1], [1, 7, 3]];
      // function solution(array, commands) {
      //     let answer = [];
      //     commands.forEach((item, index, arr)=>{
      //         answer.push(array.slice(item[0] - 1, item[1]).sort((a,b)=> a-b)[item[2]-1])
      //     })
      //     return answer;
      // }

      // //체육복
      // let arg = 2;
      // let arg2 = [1,2];
      // let arg3 = [1,2];

      // function solution(n, lost, reserve) {
      //     let answer = n - lost.length;
      //     let copy = [...lost];
      //     copy.forEach((item)=>{
      //         let i = 0;
      //         while(i < reserve.length){
      //             if(item === reserve[i]){
      //                 lost.splice(lost.indexOf(reserve[i]), 1);
      //                 reserve.splice(i, 1);
      //                 answer++;
      //                 break;
      //             }
      //             i++;
      //         }
      //     })
      //     reserve = reserve.sort((a,b)=>a-b);
      //     lost = lost.sort((a,b)=>a-b);

      //     lost.forEach((item)=>{
      //         let i = 0;
      //         while(i < reserve.length){
      //             if(reserve[i] - 1 === item || reserve[i] + 1 === item){
      //                 reserve.splice(i, 1);
      //                 answer++;
      //                 break;
      //             }
      //             i++;
      //         }
      //     })
      //     return answer;
      // }
      //체육복 간단답안 (후에 추가된 테스트 12경우 통과x - 중복삭제) Math.abs()>> 절대값 구하는 식..
      // function solution(n, lost, reserve) {
      //     return n - lost.filter(a => {
      //         const b = reserve.find(r => Math.abs(r-a) <= 1)
      //         if(!b) return true
      //         reserve = reserve.filter(r => r !== b)
      //     }).length
      // }

      // const React = (function(){
      //     let hooks = [];
      //     let idx = 0;
      //     function useState(initVal) {
      //         let _idx = idx;
      //         const state = hooks[idx] || initVal;
      //         const setState = newVal => {
      //             hooks[_idx] = newVal;
      //         };
      //         idx++;
      //         return [state, setState];
      //     }
      //     function render(Component){
      //         idx = 0;
      //         const C = Component();
      //         C.render();
      //         return C
      //     }
      //     return {useState, render};
      // })();

      // function Component() {
      //     const [count, setCount] = React.useState(1);
      //     const [text, setText] = React.useState('apple');
      //     return {
      //         render : () => console.log({count, text}),
      //         click : () => setCount(count + 1),
      //         type : word => setText(word)
      //     };
      // }
      // let App = React.render(Component);
      // App.click();
      // let App = React.render(Component);
      // App.type('pear');
      // let App = React.render(Component);
      // App.click();
      // let App = React.render(Component);
      // App.type("");
      // let App = React.render(Component);

      // //3진법 뒤집기 toString과 parseInt에 주목.. 검색하니까 바로나와서 그냥 참고했음
      // let arg = 45;
      // function solution(n) {
      //     let answer = n.toString(3).split("").reverse().join("");
      //     return parseInt(answer, 3)
      // }

      // //2016년
      // let arg = 5;
      // let arg2 = 24;
      // function solution(a, b) {
      //     //1월 1일을 금요일 1이라고 생각
      //     //하루가 늘어날때마다 +1
      //     //합인 sum % 7의 나머지가 1일때 금요일, 2일때 토요일 ...0일때는 목요일로
      //     //days 배열생성
      //     let days = ["THU","FRI","SAT","SUN","MON","TUE","WED"]
      //     let month = [0,31,29,31,30,31,30,31,31,30,31,30,31];
      //     let sum = b;
      //     for(let i = 0; i < a; i++){
      //         sum += month[i];
      //     }
      //     let answer = days[sum%7];
      //     return answer;
      // }

      // //가운데 글자 가져오기
      // let arg = "abde";
      // function solution(s) {
      //     if(s.length%2 === 1){
      //         return s.split("")[Math.floor(s.length/2)]
      //     }else{
      //         return s.split("")[s.length/2] + s.split("")[s.length/2 + 1]
      //     }
      // }

      // //같은 숫자는 싫어
      // let arg = [1,1,3,3,0,1,1];
      // function solution(arr){
      //     let answer = [];
      //     arr.forEach((item, index)=>{
      //         if(answer[answer.length - 1] !== item) answer.push(item)
      //     })
      //     return answer;
      // }
      // //같은숫자는 싫어문제에서 깔끔하게 filter를 쓴 답안
      // function solution(arr){
      //     return arr.filter((val,index) => val != arr[index+1]);
      // }

      // //나누어 떨어지는 숫자배열
      // let arg = [5, 9, 7, 10];
      // let arg2 = 5;
      // function solution(arr, divisor) {
      //     let answer = arr.filter((item)=>item%divisor === 0)
      //     if(answer.length === 0) return [-1]
      //     else return answer.sort((a,b)=>a-b)
      // }

      //두 정수의 합
      // function solution(a, b) {
      //     let answer = 0;
      //     if(a > b) [a, b] = [b, a];

      //     for(let i=a; i<=b; i++) {
      //         answer += i;
      //     }
      //     return answer;
      // }

      // //문자열 내 마음대로 정렬하기
      // let arg = ["abce", "abcd", "cdx"];
      // let arg2 = 1;
      // function solution(strings, n) {
      //     return strings.sort(function(a, b){
      //         if(a.split("")[n] > b.split("")[n]) return 1;
      //         if(a.split("")[n] < b.split("")[n]) return -1;
      //         if(a.split("")[n] === b.split("")[n]){
      //             if(a > b) return 1;
      //             if(a < b) return -1;
      //         }
      //     })
      // }
      // //같은 문자열 내 마음대로 정렬하기 문제지만.. 자극받은 풀이 ㅠ..
      // function solution(strings, n){
      //     return strings.map(a=>[...a][n]+a).sort().map(a=>a.substring(1))
      // }

      // //포켓몬
      // let arg = [3,1,2,3]
      // function solution(nums) {
      //     // 선택해야하는 숫자 = nums.length/2 -> nums.length는 항상 짝수
      //     // nums에서 선택해야하는 숫자만큼 숫자를 골라내는 경우의 수 중 제일 다양하게 선택할 수 있는 경우
      //     // 즉 nums.length/2
      //     let answer = 0;
      //     const set = new Set(nums);
      //     nums.length/2 < [...set].length
      //     ? answer = nums.length/2
      //     : answer = [...set].length
      //     return answer;
      // }

      // //문자열 내 p와 y의 개수
      // let arg = "pPoooyY";
      // function solution(s){
      //     let answer = true;
      //     s.toLowerCase().split("").filter((x)=>x==='p').length === s.toLowerCase().split("").filter((x)=>x==='y').length
      //     ? null
      //     : answer = false
      //     return answer;
      // }

      // //문자열 내림차순으로 정렬
      // let arg = "Zbcdefg";
      // function solution(s) {
      //     return s.split("").sort().reverse().join("");
      // }

      //서울에서 김서방 찾기
      // let arg = ["Jane", "Kim"];
      // function solution(seoul) {
      //     return `"김서방은 ${seoul.indexOf("Kim")}에 있다"`;
      // }

      // //문자열 다루기 기본
      // let arg = "1234";
      // function solution(s) {
      //     let answer = false;
      //     if(s.length === 4 || s.length === 6){
      //         let rex = /[^(0-9)]/g;
      //         rex.test(s) === false ? answer = true : answer = false
      //     }
      //     return answer;
      // }

      // //소수찾기
      // let arg = 10;
      // function solution(n) {
      //     let answer = Array(n+1).fill(1)
      //     for(let j = 2; j <= Math.sqrt(n); j++){
      //         if(answer[j] === 0) continue;
      //         for(let k = j; j * k <= n; k++){
      //             answer[j * k] = 0;
      //         }
      //     }
      //     let count = -2;
      //     for(let i = 0; i<answer.length; i++) answer[i] === 1 ? count ++ : null

      //     return count;
      // }

      // //같은 소수 찾기인데 유난히 빛나보이던 코드
      // let arg = 10;
      // function numberOfPrime(n) {
      //     var result = 0;
      //     var cnt=0;
      //     for(var a=2; a<=n; a++){
      //         cnt=0;
      //         for(var b=1; b<=a; b++){
      //             if(a%b === 0)
      //             cnt++;
      //         }
      //         if(cnt === 2)
      //         result++;
      //     }
      //     return result;
      // }

      // //수박수박수박
      // let arg = 5;
      // function solution(n) {
      //     let answer = '';
      //     for(let i = 0; i < Math.floor(n/2); i++){
      //         answer += "수박";
      //     }
      //     if(n % 2 !== 0) answer += "수";

      //     return answer;
      // }

      // //문자열을 정수로 바꾸기
      // let arg = '-424'
      // function solution(s){
      //     if(/^(\-|\+)?([0-9]+|Infinity)$/.test(s)) return Number(s);
      //     return NaN;
      // }

      // //시저 함호
      // let arg = "a B z"
      // let arg2 = 1
      // //65~90 A~Z, 97~122 a~z
      // function solution(s, n) {
      //     return s.split("").map((item)=>{
      //         let asciiNum = item.charCodeAt(0);
      //         if(asciiNum === 32){
      //             return asciiNum;
      //         }else{
      //             if(65<=asciiNum && asciiNum<=90){
      //                 asciiNum + n > 90
      //                 ? asciiNum -= 26-n
      //                 : asciiNum += n;
      //             }else if(97<=asciiNum && asciiNum<=122){
      //                 asciiNum + n > 122
      //                 ? asciiNum -= 26-n
      //                 : asciiNum += n;
      //             }
      //             return asciiNum;
      //         }
      //     }).map((item)=>String.fromCharCode(item)).join("")
      // }

      // //내적
      // let arg = [1,2,3,4]
      // let arg2 = 	[-3,-1,0,2]
      // function solution(a,b){
      //     let arr = []
      //     for(let i = 0; i<a.length; i++){
      //         arr.push(a[i] * b[i]);
      //     }
      //     return arr.reduce((a,b)=>a+b)
      // }

      // //약수의 합
      // let arg = 12;
      // function solution(n) {
      //     let answer = 0;
      //     for (let i = 1; i <= n; i++) {
      //         n % i === 0 ? answer += i : null
      //     }
      //     return answer;
      // }

      // //약수의 합인데 재귀를 이용한 기발한 방법이더라
      // function solution(n, a=0, b=0) {
      //     console.log(a)
      //     console.log(b)
      //     return n<=a/2 ?b :solution(n,a+1,b+=n%a?0:a);
      // }
      // //마찬가지로 약수의 합인데 효율성이 괜찮아 보임
      // function solution(n) {
      //     var answer = 0;
      //     let i;
      //     for (i = 1; i <= Math.sqrt(n); i++){
      //         if (!(n%i)) {
      //             answer += (i+n/i);
      //         }
      //     }
      //     i--;
      //     return (i === n/i) ? answer-i : answer;
      // }

      // // 이상한 문자 만들기
      // let arg = "try hello world";
      // function solution(s){
      //     return s.split(" ")
      //     .map((item)=>item.split("")
      //     .map((it,id)=>id%2 === 0 ? it.toUpperCase() : it.toLowerCase())
      //     .join(""))
      //     .join(" ")
      // }

      // //자릿수 더하기
      // let arg = 123;
      // function solution(n){
      //     let lineLength = (n+'').split('').length
      //     let sum = 0;
      //     for(let i = lineLength; i > 0; i--){
      //         let lineSum = Math.floor(n / Math.pow(10, i)) * Math.pow(10, i);
      //         sum += Math.floor(( (n-lineSum) / Math.pow(10, i-1)));
      //     }
      //     return sum;
      // }

      // // 자연수 뒤집어 배열로 만들기
      // let arg = 12345;
      // function solution(n){
      //     let answer = [];
      //     (n+"").split("").forEach((item)=>answer.unshift(parseInt(item)))
      //     return answer;
      // }

      // //정수 내림차순으로 배치하기
      // let arg = 118372;
      // function solution(n) {
      //     return parseInt((n+"").split("").sort((a,b)=>b-a).join(""))
      // }

      // //정수 제곱근 판별
      // let arg = 121;
      // function solution(n) {
      //     let answer = 0;
      //     let sqrt = Math.sqrt(n)
      //     sqrt % 1 ? answer = -1 : answer = (sqrt+1) * (sqrt+1)
      //     return answer;
      // }

      // // 제일 작은 수 제거하기
      // let arg = [4,6,3,2,1];
      // function solution(arr) {
      //     let smallest = [...arr].sort((a,b)=>a-b)[0]
      //     arr.splice(arr.indexOf(smallest), 1)
      //     if(arr.length === 0) return [-1]
      //     else return arr;
      // }

      // //짝수와 홀수
      // let arg = -3;
      // function solution(num) {
      //     return num % 2 === 0 ? 'Even' : 'Odd'
      // }

      // //최대공약수와 최소공배수
      // let arg = 10;
      // let arg2 = 12;
      // function solution(n, m) {
      //     let arrN = Array.from({length: n}, (v, i) => i+1)
      //     let arrM = Array.from({length: m}, (v, i) => i+1)
      //     n = arrN.filter((item)=>arrN.length % item === 0)
      //     m = arrM.filter((item)=>arrM.length % item === 0)
      //     let answer = []
      //     let i = n.length - 1;
      //     while(i >= 0){
      //         m.forEach((item)=>{
      //             if(item === n[i]) answer.push(item)
      //         })
      //         if(answer.length > 0) break;
      //         else i--;
      //     }
      //     answer.push(m[m.length-1] * n[n.length-1] / answer[0])
      //     return answer;
      // }

      // // 키패드 누르기
      // let arg = [1, 3, 4, 5, 8, 2, 1, 4, 5, 9, 5];
      // let arg2 = "right";
      // function solution(numbers, hand) {
      //     let answer = '';
      //     let currentLeftHand = [-1, 0];
      //     let currentRightHand = [1, 0];

      //     numbers.forEach((item, index, arr)=>{
      //         if(item === 1 || item === 4 || item === 7) {
      //             let itemLocation = item === 1 ? 3 : item === 4 ? 2 : 1;
      //             answer += "L";
      //             currentLeftHand = [-1, itemLocation];
      //         }
      //         else if(item === 3 || item === 6 || item === 9) {
      //             let itemLocation = item === 3 ? 3 : item === 6 ? 2 : 1
      //             answer += "R";
      //             currentRightHand = [1, itemLocation];
      //         }
      //         else{
      //             let itemLocation = item === 2 ? 3 : item === 5 ? 2 : item === 8 ? 1 : 0;
      //             let currentButton = [0, itemLocation];
      //             let leftAbs = Math.abs(currentLeftHand[0]-currentButton[0]) + Math.abs(currentLeftHand[1]-currentButton[1]);
      //             let rightAbs = Math.abs(currentRightHand[0]-currentButton[0]) + Math.abs(currentRightHand[1]-currentButton[1]);
      //             if(leftAbs === rightAbs){
      //                 answer += hand[0].toUpperCase();
      //                 if(hand === "left") currentLeftHand = [0, itemLocation];
      //                 else currentRightHand = [0, itemLocation];
      //             }else if(leftAbs < rightAbs){
      //                 answer += "L";
      //                 currentLeftHand = [0, itemLocation];
      //             }
      //             else{
      //                 answer += "R";
      //                 currentRightHand = [0, itemLocation]
      //             }
      //         }
      //     })
      //     return answer;
      // }

      // // 콜라츠 추측
      // let arg = 626331;
      // function solution(num) {
      //     let answer = 0;
      //     const Collatz = (n) => {
      //         if(n === 1) return answer;
      //         n % 2 === 0 ? n = n/2 : n = n*3 + 1
      //         answer += 1;
      //         if(answer === 500){
      //             answer = -1;
      //             return answer;
      //         }
      //         Collatz(n);
      //     }
      //     Collatz(num);
      //     return answer;
      // }

      // //평균 구하기
      // let arg = [1,2,3,4];
      // function solution(arr) {
      //     let answer = 0;
      //     arr.forEach((item)=>answer += item)
      //     return answer/arr.length;
      // }

      // //하샤드 수
      // let arg = 120;
      // function solution(x) {
      //     let sum = 0;
      //     let xLength = (x+'').split("").length
      //     let xCopy = x;
      //     for(let i = xLength; i > 0; i--){
      //         sum += Math.floor(xCopy / Math.pow(10, i-1));
      //         xCopy %= Math.pow(10, i-1);
      //     }
      //     return x % sum === 0 ? true : false
      // }

      // //핸드폰 번호 가리기
      // let arg = "01033334444"
      // function solution(phone_number) {
      //     let answer = '';
      //     let leg = phone_number.length
      //     for(let i = 0; i < leg-4; i++) answer += '*'
      //     return answer+phone_number.substring(leg-4, leg);
      // }

      // //행렬의 덧셈
      // let arg = [[1,2],[2,3]];
      // let arg2 = [[3,4],[5,6]];
      // function solution(arr1, arr2) {
      //     return arr1.map((item, index)=>item.map((it, idx)=>it + arr2[index][idx]))
      // }

      // //x만큼 간격이 있는 숫자
      // let arg = 2;
      // let arg2 = 5;
      // function solution(x, n) {
      //     let answer = [];
      //     let plusNumber = x;
      //     for(let i = 0; i<n; i++){
      //         answer.push(x)
      //         x += plusNumber;
      //     }
      //     return answer;
      // }

      // process.stdin.setEncoding('utf8');
      // process.stdin.on('data', data => {
      //     const n = data.split(" ");
      //     const a = Number(n[0]), b = Number(n[1]);
      //     let answer = '';
      //     for(let i = 0; i < b; i++){
      //         for(let l = 0; l < a; l++){
      //             answer += '*'
      //         }
      //         console.log(answer);
      //         answer = '';
      //     }
      // });

      // //소수 만들기
      // //3개 뽑아서 소수
      // let arg = [1,2,3,4]
      // function solution(nums) {
      //     const getCombinations =  (newArr, selectNumber) => {
      //         const results = [];
      //         if (selectNumber === 1) return newArr.map((value) => [value]);

      //         newArr.forEach((fixed, index, origin) => {
      //         const rest = origin.slice(index + 1);
      //         const combinations = getCombinations(rest, selectNumber - 1);
      //         const attached = combinations.map((combination) => [fixed, ...combination]);
      //         results.push(...attached);
      //         });

      //         return results;
      //     }
      //     const res = getCombinations(nums, 3);
      //     let answer = 0;
      //     res.forEach((item)=>{
      //         let sum = item.reduce((a,b)=>a+b);
      //         let cnt = 0;
      //         for(let a=1; a<=sum; a++){
      //             if(sum % a === 0) cnt++;
      //         }
      //         if(cnt === 2) answer++;
      //     })
      //     return answer;
      // }

      //인자로는 원본배열과, 자른배열, 잘린배열
      //함수는 정렬된 원본배열을 받아서 [1,2,3,4,5,6,7]
      //만약 자른배열이 [1,2,3] budget보다 작은경우
      // 배열들을 리턴하고 작은경우 함수를 실행
      //작은경우 함수는 잘린배열의 반을 붙이고 다시 재귀실행
      //언제까지 ? 붙였을때 합이 budget보다 커질때까지
      //커진다면 자른배열을 리턴하고 잘린배열의 0번째부터 더하면서
      //카운트 = 자른배열.length , 커지는 조건은 budget보다 커지기 전까지
      // 큰경우 함수실행은
      //반대로 자른배열을 다시 한번 더 반으로 자르는
      //것을 재귀, 언제까지 ? budget보다 작아질때까지
      //작아지면 다시 하나씩 더하면서 ~~ 반복
      // let arg = [1,3,2,5,4];
      // let arg2 = 9;
      // function solution(d, budget) {
      //     let sum = d.reduce((a,b)=>a+b);
      //     if(sum <= budget) return d.length;

      //     const arrSlice = (origin)=>{ //배열을 반으로 잘라 반과 나머지배열을 각각 return해주는 함수
      //         const halfArr = origin.slice(0, Math.ceil(origin.length/2));
      //         const restArr = origin.slice(Math.ceil(origin.length/2));
      //         return [halfArr, restArr];
      //     }

      //     const halfIsSmall = (half, rest)=>{
      //         let standard = half.reduce((a,b)=>a+b);
      //         let result = half.length;
      //         if(standard > budget){
      //             while(standard > budget){
      //                 standard -= half[result-1];
      //                 result--;
      //             }
      //             return result;
      //         }else{
      //             [halfArr, restArr] = arrSlice(rest);
      //             const halfPlusRest = half.concat(halfArr);
      //             return halfIsSmall(halfPlusRest, restArr);
      //         }

      //     }
      //     const halfIsBig = (half, rest)=>{
      //         let standard = half.reduce((a,b)=>a+b);
      //         let result = half.length;
      //         if(standard < budget){
      //             while(standard < budget){
      //                 standard += rest[0];
      //                 result++;
      //             }
      //             return result-1;
      //         }else{
      //             [halfArr, restArr] = arrSlice(half);
      //             const restPlusHalf = rest.concat(restArr);
      //             return halfIsBig(halfArr, restPlusHalf);
      //         }
      //     }
      //     // 코드시작, 정렬된 sortArr의 halfArr 모든요소의합이 지원금액보다 작다면
      //     // halfIsSmall 재귀함수 실행
      //     // 크다면 HalfIsBig 실행,
      //     let sortArr = d.sort((a,b)=>a-b);
      //     [halfArr, restArr] = arrSlice(sortArr);
      //     const halfsum = halfArr.reduce((a,b)=>a+b);

      //     if(halfsum === budget) return halfArr.length;
      //     else if(halfsum < budget) return halfIsSmall(halfArr, restArr);
      //     else return halfIsSmall(halfArr, restArr);
      // }

      // let arg = 5;
      // let arg2 = 	[1,1,1,3,3];
      // //실패율
      // function solution(N, stages) {
      //     let answer = [];
      //     let res = [];
      //     let people = stages.length;

      //     stages.forEach((item, index, arr)=>{
      //         if(res[item]) res[item][1] += 1;
      //         else res[item] = [item, 1];
      //     })

      //     for(let i = 1; i<=N; i++){
      //         if(res[i] === undefined) res[i] = [i, 0]
      //     }

      //     res.map((item, index, arr)=>{
      //         let itemCp = item[1];
      //         item[1] /= people;
      //         people -= itemCp;
      //         return item;
      //     }).sort((a,b)=>b[1]-a[1])
      //     .forEach((it)=>{
      //         if(it[0] !== N+1) answer.push(it[0])
      //     })

      //     return answer;
      // }

      // // 다트게임
      // let arg = "1D2S#10S"
      // function solution(dartResult) {
      //     let res = dartResult.replace(/[0-9]+[A-Z]|[*]|[#]/g, "\/$&").split('/');
      //     let answer = [];
      //     for(let i = 1; i < res.length; i++){
      //         if(res[i] !== '*' && res[i] !== '#'){
      //             res[i] = res[i].replace(/[A-Z]/g, "\/$&").split('/');
      //             let sq = res[i][1];
      //             res[i][1] === 'S' ? sq = 1 : res[i][1] === 'D' ? sq = 2 : sq = 3;
      //             answer.push(Math.pow(+res[i][0],sq));
      //         }else{
      //             if(res[i]==='*'){
      //                 if(answer.length === 1) answer[0] *= 2;
      //                 else{
      //                     answer[answer.length-1] *= 2;
      //                     answer[answer.length-2] *= 2;
      //                 }
      //             }else{
      //                 answer[answer.length-1] *= -1;
      //             }
      //         }
      //     }
      //     return answer.reduce((a,b)=>a+b);
      // }

      // //비밀지도
      // let arg = 6
      // let arg2 = 	[46, 33, 33 ,22, 31, 50]
      // let arg3 = [27 ,56, 19, 14, 14, 10]
      // function solution(n, arr1, arr2) {
      //     const parseBinary = (arr)=>{
      //         return arr.map((item)=>{
      //         let parseTwo = item.toString(2);
      //             if(parseTwo.length !== n){
      //                 while(parseTwo.length < n){
      //                     parseTwo = '0' + parseTwo;
      //                 }
      //             }
      //             return parseTwo;
      //         })
      //     }
      //     const newArr1 = parseBinary(arr1)
      //     const newArr2 = parseBinary(arr2)

      //     let answer = [];
      //     for(let i = 0; i<n; i++){
      //         let str = ''
      //         for(let l = 0; l<n; l++){
      //             if(newArr1[i].split('')[l] === '0' && newArr2[i].split('')[l] === '0') str += ' '
      //             else str += '#'
      //         }
      //         answer.push(str)
      //     }
      //     return answer;
      // }

      // ----level2------

      // //다리를 지나는 트럭
      // function solution(bridge_length, weight, truck_weights) {
      //     let time = 0;
      //     let completeTruck = [];
      //     let progressTruck = Array(bridge_length).fill(0);
      //     let restTruck = [...truck_weights];
      //     let limitWeight = 0;

      //     while(true){
      //         time++;
      //         let currentWeight = progressTruck.shift();
      //         limitWeight -= currentWeight;
      //         if(completeTruck.length === truck_weights.length) break;
      //         else if(limitWeight+restTruck[0] <= weight){
      //             limitWeight += restTruck[0];
      //             progressTruck.push(restTruck[0]);
      //             restTruck.shift();
      //         }else{
      //             progressTruck.push(0);
      //         }
      //         progressTruck[0] !== 0 ? completeTruck.push(progressTruck[0]) : null
      //     }
      //     return time;
      // }

      // //프린터
      // let arg = [3,3,4,2]
      // let arg2 = 3;
      // function solution(priorities, location) {
      //     let cnt = 0;
      //     const findNumber = priorities[location];
      //     priorities[location] += 0.9;
      //     let biggestNum = Math.max(...priorities);
      //     priorities = priorities.filter((x)=>x>=findNumber);
      //     while(biggestNum !== 0){
      //         const findIdx = priorities.indexOf(biggestNum);
      //         // console.log(`찾는 인덱스는${findIdx}이고 가장 큰 숫자는${biggestNum}`)
      //         if(findIdx === -1){
      //             if(priorities.length === 1){
      //                 cnt++;
      //                 break;
      //             }
      //             biggestNum--;
      //         }else{
      //             if(findNumber === biggestNum || findNumber+0.9 === biggestNum){
      //                 cnt += priorities.indexOf(findNumber+0.9) + 1;
      //                 break;
      //             }else{
      //                 const sliceResult = priorities.slice(0, findIdx);
      //                 const spliceResult = priorities.splice(findIdx+1);
      //                 priorities = spliceResult.concat(sliceResult);
      //                 cnt++;
      //             }
      //         }
      //     }
      //     return cnt;
      // }

      // //스킬트리
      // let arg = "CBD"
      // let arg2 = ["BACDE", "CBADF", "AECB", "BDA"]
      // function solution(str, arr) {
      //     return arr.map((itemInArr)=>{
      //         return itemInArr.split('').map((itemInItem)=>{
      //             return str.split('').map((itemInStr)=>{
      //                 if(itemInItem === itemInStr) return itemInStr;
      //                 else return null;
      //             }).join('')
      //         }).join('').split('')
      //         .map((val, idx)=>{
      //             if(str[idx] !== val) return false;
      //             else return true;
      //         }).indexOf(false) === -1
      //     }).filter((x)=>x===true).length
      // }

      // //기능개발
      // let arg = [93, 30, 55]
      // let arg2 = [1, 30, 5]
      // function solution (progresses, speeds){
      //     const shiftArr = (progresses, speeds, cnt, answer)=>{
      //         if(progresses.length === 0) return answer;

      //         if(progresses[0] >= 100) {
      //             cnt++;
      //             if(progresses[1] < 100 || progresses[1] === undefined) {
      //                 answer.push(cnt);
      //                 cnt = 0;
      //             }
      //             progresses.shift();
      //             speeds.shift();
      //             return shiftArr(progresses, speeds, cnt, answer);
      //         }else{
      //             return shiftArr(progresses.map((item, index)=>item+speeds[index]), speeds, cnt, answer);
      //         }
      //     }
      //     let count = 0;
      //     let answer = [];
      //     return shiftArr(progresses, speeds, count, answer);
      // }

      //멀쩡한 사각형
      // let arg = 2;
      // let arg2 = 100;
      // function solution(w, h) {
      //     [w, h] = w <= h ? [w, h] : [h, w];
      //     let movedDistance, i = 0, cutedSquare = h;

      //     while(i < w){
      //         i++;
      //         movedDistance = h*i/w;
      //         if(!Number.isInteger(movedDistance)) cutedSquare++;
      //         else{
      //             if (i === 1) break;
      //             else if (w%i === 0 && h%i === 0 && w !== h) {
      //                 cutedSquare += w/i - 1;
      //                 break;
      //             }
      //         }
      //     }
      //     return (w*h) - cutedSquare;
      // }

      // //1,2,4 나라
      // let arg = 6;
      // function solution(n) {
      //     const result = ['4', '1', '2'];
      //     let answer = '';
      //     while(n !== 0){
      //         answer = result[n%3] + answer;
      //         n = (n%3 === 0)? n/3 - 1 : Math.floor(n/3);
      //     }
      //     return +answer;
      // }

      // //가장큰수
      // let arg = [6, 10, 2];
      // //재귀로
      // function solution(numbers) {
      //     const newArr = []
      //     numbers.map((item)=>item+"").forEach((v, i, orgin)=>{
      //         const fixedValue = v;
      //         const restNumbers = orgin.splice(i, 1)
      //         console.log((restNumbers))
      //     })
      //
      // }

      //카카오커머스
      //문제1
      // let arg = [5, 4, 5, 4, 5] //가지고있는 상품권
      // let arg2 = [1, 2, 3, 5, 4] //가지고싶은 상품권
      // function solution(gift_cards, wants) {
      //     const chageCard = (current, goal, i, origin)=>{
      //         if(current.length === i) return current;
      //
      //         if (current[i] === goal[i]) return chageCard(current, goal, ++i, origin);
      //
      //         const find = goal[i];
      //         const wantsIndex = current.indexOf(find);
      //         //조건문 추가 가지고있는 상품권이 교환이 안됬다면, 앞선 인덱스에서
      //
      //         if (i > wantsIndex && current[i] !== origin[i]) return chageCard(current, goal, ++i, origin);
      //         else{
      //             let temp = '';
      //             temp = current[i];
      //             current[i] = current[wantsIndex];
      //             current[wantsIndex] = temp;
      //             return chageCard(current, goal, ++i, origin);
      //         }
      //
      //     }
      //     const result = chageCard(gift_cards, wants, 0, gift_cards);
      //     return result.filter((item,index)=>item !== wants[index]).length
      // }

      // //행렬의 곱셈
      // let arg =[ //   [[1, 4],
      //             //   [2, 5],
      //     //           [3, 6]]
      //     [1, 2, 3],
      //     [4, 5, 6]]
      // let arg2 = [[1, 4], [2, 5], [3, 6]]
      // function solution(arr1, arr2) {
      //     return arr1.map((item)=>{
      //         const newArr = [];
      //         for(let i = 0; i < arr2[i].length; i++){
      //             let sum = 0;
      //             for(let l = 0; l < item.length; l++){
      //                 sum += item[l] * arr2[l][i];
      //             }
      //             newArr.push(sum)
      //         }
      //         return newArr;
      //     })
      // }

      // // 삼각 달팽이
      // let arg = 7;
      // function solution(n) {
      //     let N = n;
      //     N % 2 === 0 ? N = (N+1)*(N/2) : N = (N+1) * (Math.floor(N/2)) + Math.ceil(N/2);
      //     const answer = Array(N).fill(0);
      //
      //     let dir = "내려가기";
      //     let location = 0, cnt = 0, num = 1;
      //     while(num <= answer.length){
      //         switch (dir){
      //             case "내려가기":
      //                 if (++cnt !== 1) location += cnt++;
      //                 let downStandard = cnt;
      //                 while(answer[location] === 0){
      //                         answer[location] = num++;
      //                         location += downStandard++;
      //                 }
      //                 dir = "옆으로가기";
      //                 location -= --downStandard;
      //             case "옆으로가기":
      //                 location++;
      //                 while(answer[location] === 0){
      //                     answer[location++] = num++;
      //                 }
      //                 dir = "올라가기";
      //                 location--;
      //             case "올라가기":
      //                 location -= n--;
      //                 let upStandard = n;
      //                 while(answer[location] === 0){
      //                     answer[location] = num++;
      //                     location -= upStandard--;
      //                 }
      //                 dir = "내려가기";
      //                 location += ++upStandard;
      //         }
      //     }
      //     return answer;
      // }

      //문자열압축
      // let arg = "aabbaccc";
      // function solution(s) {
      //     if (s.length === 1) return 1;
      //     const divisible = [];
      //     for(let i = 1; i <= s.length/2; i++) divisible.push(i);
      //
      //     return divisible.map((item)=>{
      //         const newArr = [];
      //         let temp = '';
      //         s.split('').forEach((v, i)=>{
      //             temp += v;
      //             if ((i+1) % item === 0) {
      //                 newArr.push(temp);
      //                 temp = '';
      //             }
      //             if ((i+1) === s.length &&
      //                 (i+1) / item > Math.floor(s.length / item))
      //                 newArr.push(temp);
      //         })
      //         return newArr;
      //     })
      //     .map((item)=>{
      //         let cnt = 1;
      //         const newArr = [];
      //         item.forEach((v, i)=> {
      //             if (v === item[i + 1]) cnt++;
      //             else{
      //                 cnt === 1 ? newArr.push(v) : newArr.push(`${cnt}${v}`);
      //                 cnt = 1;
      //             }
      //         })
      //         return newArr.join("").length;
      //     })
      //     .sort((a,b)=>a-b)[0]
      // }

      // ▲ - 다음 알파벳
      // ▼ - 이전 알파벳 (A에서 아래쪽으로 이동하면 Z로)
      // ◀ - 커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서)
      // ▶ - 커서를 오른쪽으로 이동
      // //조이스틱
      // const arg = "BBAAB";
      // function solution(name) {
      //     let cnt = 0;
      //     const AorNot = [];
      //     for(let i = 0; i < name.length; i++){
      //         const charCode = name.charCodeAt(i)
      //         if (charCode <= 78) cnt += charCode - 65;
      //         else cnt += 91 - charCode;
      //         name[i] === "A" ? AorNot.push(0) : AorNot.push(1)
      //     }
      //
      //     for(let i = 1; i < AorNot.length; i++){
      //         if (AorNot[i]) cnt++;
      //         else{
      //             const next = AorNot.indexOf(1, i)
      //             if (next - (i-1) < (i-1) + 1) cnt++;
      //             else{
      //                 cnt += (i-1) + (AorNot.length-1) - next + 1
      //                 break;
      //             }
      //         }
      //     }
      //
      //     return cnt;
      // }

      // //큰수만들기
      // const arg = "1231324";
      // const arg2 = 3;
      // //67429495152
      // //79495152
      // function solution(number, k) {
      //     const checkNumberOfDigits = (arr, res, k, max) => {
      //         while(res.length < arr.length - k){
      //             for(let i = 0; i < arr.length; i++){
      //                 if (arr[i] == max && i > res[0]){
      //                     if (arr.length - i + res.length <= arr.length - k) {
      //                         for (let j = i; j < arr.length; j++) res.push(j);
      //                         break;
      //                     }
      //                     else {
      //                         res.push(i);
      //                         break;
      //                     }
      //                 }
      //             }
      //             max--;
      //         }
      //         while(res.length !== arr.length - k) res.pop();
      //         return res.sort((a,b)=>a-b).map((item)=>arr[item]).join("");
      //     }
      //
      //     const findMaxNum = (arr, k) => {
      //         let max = Math.max(...arr);
      //         let res = [];
      //
      //         arr.forEach((item, index) => item == max ? res.push(index): null);
      //         res = res.filter((v)=>arr.length - v > arr.length - k)
      //         if (res.length > 0) {
      //             return checkNumberOfDigits(arr, res, k, max);
      //         }else{
      //             while(arr.indexOf(max+"") > k || arr.indexOf(max+"") === -1) max--;
      //             res.push(arr.indexOf(max+""));
      //             max = Math.max(...arr);
      //             return checkNumberOfDigits(arr, res, k, max);
      //         }
      //     }
      //
      //     return findMaxNum(number.split(""), k);
      // }

      // function solution(number, k) {
      //     const cb =  (newArr, selectNumber) => {
      //         const results = [];
      //         if (selectNumber === 1) return newArr.map((value) => [value]);
      //
      //         newArr.forEach((fixed, index, origin) => {
      //             const rest = origin.slice(index + 1);
      //             const combinations = cb(rest, selectNumber - 1);
      //             const attached = combinations.map((combination) => [fixed, ...combination]);
      //             results.push(...attached);
      //         });
      //
      //         return results;
      //     }
      //     return  cb(number.split(""), number.length-k).map((item)=>item.join("")).sort((a,b)=>b-a)[0]
      // }

      //밑에 3문제는 4월 프로그래머스 월간코딩챌린지
      // //음양더하기
      // let arg = [4,7,12];
      // let arg2 = [true,false,true];
      // function solution(absolutes, signs) {
      //     let answer = 0;
      //     absolutes.forEach((item, index)=>
      //         signs[index] === true ? answer += item : answer += item*-1
      //     )
      //     return answer;
      // }

      // //괄호 회전하기
      // let arg = "[](){}";
      // function solution(s) {
      //     if(s.length % 2 === 1) return 0;
      //     let answer = true, cnt = 0;
      //     let arr = [];
      //     for(let j = 0; j < s.length; j++){
      //         for(let i = 0; i < s.length; i++){
      //             if (s[i] === "[" || s[i] === "{" || s[i] === "(") arr.push(s[i]);
      //             else {
      //                 const close = arr[arr.length-1] + s[i];
      //                 if (close === "[]" || close === "{}" || close === "()") arr.pop();
      //                 else {
      //                     answer = false;
      //                     break;
      //                 }
      //             }
      //         }
      //         if (answer) cnt++;
      //         answer = true, arr = [];
      //         const shiftValue = s[0];
      //         s = s.substring(1, s.length) + shiftValue;
      //     }
      //     return cnt;
      // }

      // 모두 0으로 만들기 level3,, 해결못함
      // let arg=[-5,0,2,1,2];
      // let arg2=[[0,1],[3,4],[2,3],[0,3]];
      // //result = 9;
      // function solution(a, edges) {
      //     const matrix = new Map();
      //         for(let j = 0; j < edges.length; j++){
      //             matrix.set([a[edges[j][0]], a[edges[j][1]]], 1)
      //         }
      //     console.log(matrix)
      //     // for(let i = 0; i < edges.length; i++){
      //     //     matrix.get(a[edges[i][0]]).push(a[edges[i][1]])
      //     //     matrix.get(a[edges[i][1]]).push(a[edges[i][0]])
      //     // }
      //     let cnt = 0;
      //
      //     // for (let [key, value] of matrix) {
      //     //     console.log(key + ' = ' + value);
      //     //     if (key !== 0){
      //     //         for(let i = 0; i < Math.abs(key); i++){
      //     //             // console.log(value)
      //     //             for (let j = 0; j < value.length; j++){
      //     //                 if(value[j] !== 0){
      //     //                     if (key > 0) {
      //     //                         // matrix.delete(key)
      //     //                         // matrix.
      //     //                     }
      //     //                 }
      //     //             }
      //     //         }
      //     //     }
      //     // }
      // }


      // //소수찾기
      // let arg = "011"
      // function solution(numbers) {
      //   const getPermutations = (arr, selectNumber) => {
      //     const results = [];
      //     if (selectNumber === 1) return arr;
      //     arr.forEach((fixed, index, origin) => {
      //       const rest = [...origin.slice(0, index), ...origin.slice(index+1)]
      //       const permutations = getPermutations(rest, selectNumber - 1);
      //       const attached = permutations.map((permutation) => [fixed, ...permutation].join(""));
      //       results.push(...attached);
      //     });
      //     return results;
      //   };
      //
      //   const isPrime = (num)=>{
      //     let start = 2;
      //     while (start <= Math.sqrt(num)) {
      //       if (num % start++ < 1) {
      //         return false;
      //       }
      //     }
      //     return num > 1;
      //   }
      //
      //   let newArr = [];
      //   for(let i = 1; i <= numbers.length; i++) newArr.push(getPermutations(numbers.split(""), i));
      //   newArr = newArr.reduce((acc, cur) => acc.concat(cur)).map((v)=>+v)
      //   const set = new Set(newArr);
      //
      //   return [...set].filter((v)=>isPrime(v)).length
      // }


      //가장 큰 수
      // let arg = [3, 30, 34, 5, 9];
      //버블정렬
      // function solution(numbers) {
      //   if (numbers.filter((v)=>v>0).length === 0) return '0';
      //   numbers = numbers.map((v)=>v+'');
      //   for (let i = 0; i < numbers.length; i++) {
      //     for (let j = 0; j < numbers.length - 1 - i; j++) {
      //       if (numbers[j] + numbers[j+1] < numbers[j+1] + numbers[j])
      //         [numbers[j], numbers[j+1]] = [numbers[j+1], numbers[j]];
      //     }
      //   }
      //   return numbers.join('');
      // }

      //삽입정렬
      // function solution (numbers) {
      //   if (numbers.filter((v)=>v>0).length === 0) return '0';
      //   numbers = numbers.map((v)=>v+'');
      //   for (let i = 1; i < numbers.length; i++) {
      //     let cur = numbers[i];
      //     let left = i - 1;
      //     while (left >= 0 && numbers[left] + cur < cur + numbers[left]) {
      //       numbers[left + 1] = numbers[left];
      //       left--;
      //     }
      //     numbers[left + 1] = cur;
      //   }
      //   return numbers.join('');
      // }

      // 선택정렬
      // function solution (numbers) {
      //   if (numbers.filter((v)=>v>0).length === 0) return '0';
      //   numbers = numbers.map((v)=>v+'');
      //   for (let i = 0; i < numbers.length; i++) {
      //     let minIndex = i;
      //     for (let j = i + 1; j < numbers.length; j++) {
      //       if (numbers[minIndex] + numbers[j] < numbers[j] + numbers[minIndex])
      //         minIndex = j;
      //     }
      //     if (minIndex !== i)
      //       [numbers[minIndex], numbers[i]] = [numbers[i], numbers[minIndex]];
      //   }
      //   return numbers.join('');
      // }

      //퀵정렬 .. 테스트케이스는 실패라고 뜨나 반례를 찾을 수 없을 정도로 꽤나 합리적인 코드라고 생각..
      // function solution (numbers) {
      //   if (numbers.filter((v)=>v>0).length === 0) return '0';
      //   const quickSort = (arr) =>{
      //     if (arr.length < 2) return arr;
      //
      //     const pivot = [arr[0]];
      //     const left = [];
      //     const right = [];
      //     for (let i = 1; i < arr.length; i++) {
      //       if (arr[i] + pivot > pivot + arr[i]) left.push(arr[i]);
      //       else if (arr[i] + pivot < pivot + arr[i]) right.push(arr[i]);
      //       else pivot.push(arr[i]);
      //     }
      //     return quickSort(left).concat(pivot, quickSort(right));
      //   }
      //   return quickSort(numbers.map((v)=>v+'')).join('')
      // }

      // //sort함수
      // function solution(numbers){
      //   if (numbers.filter((v)=>v>0).length === 0) return '0';
      //   return numbers.map((v)=>v+'').sort((a, b)=>{
      //     if (a+b > b+a) return (b+a) - (a+b);
      //   }).join('');
      // }


      // //H-Index
      // const arg = [2, 2];
      // function solution(citations) {
      //   if (citations.filter((v)=> v>0).length === 0) return 0;
      //   citations = citations.sort((a, b) => a-b);
      //   let j = 0;
      //   let standard = citations.length;
      //   while(j <= citations.length){
      //     for(let i = 0; i < citations.length; i++){
      //       if (citations[i] >= j){
      //         standard = i;
      //         break;
      //       }
      //     }
      //     if (standard > j || citations.length - standard < j) break;
      //     j++;
      //   }
      //   return j-1;
      // }


      //카카오 인턴쉽 1번
      // let arg = 'one4seveneight'
      // function solution(s) {
      //   const sArr = s.split("");
      //   const en = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'];
      //   let temp = 0;
      //   en.forEach((item, index)=>{
      //     while(true){
      //       let foundEn = s.indexOf(item, temp);
      //       if (foundEn === -1) break;
      //
      //       sArr.splice(foundEn, item.length, index);
      //       s = sArr.join("");
      //       temp = foundEn + 1;
      //     }
      //     temp = 0;
      //   })
      //   return +s;
      // }


      //카카오 인턴쉽 2번
      let arg =
              [["PXPOX", "XPXOX", "PXPXX", "OOXOX", "XOXXX"],
                ["POOPX", "OXPXP", "PXXXO", "OXXXO", "OOOPP"],
                ["PXOPX", "OXOXP", "OXPXX", "OXXXP", "POOXX"],
                ["OOOXX", "XOOOX", "OOOXX", "OXOOX", "OOOOO"],
                ["PXPXP", "XPXPX", "PXPXP", "XPXPX", "PXPXP"]];

      //No.	0	1	2	3	4
      // 0	P	X	P	O	X
      // 1	X	P	X	O	X
      // 2	P	X	P	X	X
      // 3	O	O	X	O	X
      // 4	X	O	X	X	X
      //result = [1, 0, 1, 1, 1]
      //P 는 응시자가 앉아있는 자리를 의미합니다.
      //O 는 빈 테이블을 의미합니다.
      //X 는 파티션을 의미합니다.
      function solution(places){
        return places.map((item)=>{
          let res = true;
          let person = [];
          item.forEach((it, x)=>{
            for (let y = 0; y < 5; y++)
              if (it[y] === "P") person.push([x,y]);
          })
          person.forEach((lc, idx, arr)=>{
            for (let i = 1; i + idx < person.length; i++){
              if (Math.abs(lc[0] - arr[idx+i][0]) + Math.abs(lc[1] - arr[idx+i][1]) === 2) {
                if (lc[0] === arr[idx+i][0]){ //같은 행
                  if (item[lc[0]][lc[1]+1] !== "X") res = false;
                }
                else if(lc[1] === arr[idx+i][1]) { //같은 열
                  if (item[lc[0]+1][lc[1]] !== "X") res = false;
                }
                else if(Math.abs(lc[0] - arr[idx+i][0]) === 1 && Math.abs(lc[1] - arr[idx+i][1]) === 1) { // 대각선
                  if (lc[1] < arr[idx+1][1]){ //왼쪽에서 오른쪽아래
                    if (item[lc[0]][lc[1] + 1] !== "X" || item[arr[idx + i][0]][arr[idx + i][1] - 1] !== "X") {
                      res = false;
                    }
                  }else { // 오른쪽에서 왼쪽아래
                    if (item[lc[0]][lc[1] - 1] !== "X" || item[arr[idx + i][0]][arr[idx + i][1] + 1] !== "X") {
                      res = false;
                    }
                  }
                  continue;
                }
              } else if (Math.abs(lc[0] - arr[idx+i][0]) + Math.abs(lc[1] - arr[idx+i][1]) < 2) res = false;
            }
          });

          if (res) return 1;
          else return 0;
        })
      }

      console.log(solution(arg));
    </script>

    <script>
      // 사이냅 소프트 while문ver
      // let arg = 54;
      // function solution(n){
      //     let cnt = 0;
      //     while(n !== 0){
      //         if(n % 2 !== 0){
      //             cnt++;
      //             n--;
      //         }else{
      //             cnt++;
      //             n /= 2;
      //         }
      //     }
      //     return `${cnt}단계`;
      // }

      // 사이냅소프트 퀴즈 재귀ver
      // let arg = 10333212412;
      // function solution(n){
      //     let arr = [];
      //     const decomposition = (number)=>{
      //         if(number === 0) return `${arr.length}단계`;

      //         if(number % 2 !== 0){
      //             arr.push(1);
      //             return decomposition(number-1);
      //         }else{
      //             arr.push(2);
      //             return decomposition(number/2);
      //         }
      //     }
      //     return decomposition(n);
      // }
    </script>
  </body>
</html>
